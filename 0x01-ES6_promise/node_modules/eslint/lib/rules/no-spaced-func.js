/**
 * @fileoverview Rule to check that spaced function application
 * @author Matt DuVall <http://www.mattduvall.com>
 * @deprecated in ESLint v3.3.0
 */

"use strict";

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

<<<<<<< HEAD
=======
/** @type {import('../shared/types').Rule} */
>>>>>>> 2ddce255cccd5c3f5dc8c68e12add2eef5d3e217
module.exports = {
    meta: {
        type: "layout",

        docs: {
<<<<<<< HEAD
            description: "disallow spacing between function identifiers and their applications (deprecated)",
            category: "Stylistic Issues",
            recommended: false,
            url: "https://eslint.org/docs/rules/no-spaced-func"
=======
            description: "Disallow spacing between function identifiers and their applications (deprecated)",
            recommended: false,
            url: "https://eslint.org/docs/latest/rules/no-spaced-func"
>>>>>>> 2ddce255cccd5c3f5dc8c68e12add2eef5d3e217
        },

        deprecated: true,

        replacedBy: ["func-call-spacing"],

        fixable: "whitespace",
<<<<<<< HEAD
        schema: []
=======
        schema: [],

        messages: {
            noSpacedFunction: "Unexpected space between function name and paren."
        }
>>>>>>> 2ddce255cccd5c3f5dc8c68e12add2eef5d3e217
    },

    create(context) {

<<<<<<< HEAD
        const sourceCode = context.getSourceCode();
=======
        const sourceCode = context.sourceCode;
>>>>>>> 2ddce255cccd5c3f5dc8c68e12add2eef5d3e217

        /**
         * Check if open space is present in a function name
         * @param {ASTNode} node node to evaluate
         * @returns {void}
         * @private
         */
        function detectOpenSpaces(node) {
            const lastCalleeToken = sourceCode.getLastToken(node.callee);
            let prevToken = lastCalleeToken,
                parenToken = sourceCode.getTokenAfter(lastCalleeToken);

            // advances to an open parenthesis.
            while (
                parenToken &&
                parenToken.range[1] < node.range[1] &&
                parenToken.value !== "("
            ) {
                prevToken = parenToken;
                parenToken = sourceCode.getTokenAfter(parenToken);
            }

            // look for a space between the callee and the open paren
            if (parenToken &&
                parenToken.range[1] < node.range[1] &&
                sourceCode.isSpaceBetweenTokens(prevToken, parenToken)
            ) {
                context.report({
                    node,
                    loc: lastCalleeToken.loc.start,
<<<<<<< HEAD
                    message: "Unexpected space between function name and paren.",
=======
                    messageId: "noSpacedFunction",
>>>>>>> 2ddce255cccd5c3f5dc8c68e12add2eef5d3e217
                    fix(fixer) {
                        return fixer.removeRange([prevToken.range[1], parenToken.range[0]]);
                    }
                });
            }
        }

        return {
            CallExpression: detectOpenSpaces,
            NewExpression: detectOpenSpaces
        };

    }
};
